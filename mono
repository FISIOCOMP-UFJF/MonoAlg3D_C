#!/bin/bash

CUSTOM_FILE_NAME="custom_functions.c"

STIM_LIB_PATH="src/stimuli_library/"
CUSTOM_STIM_FILE="${STIM_LIB_PATH}""${CUSTOM_FILE_NAME}"
DEFAULT_STIM_FILE=${STIM_LIB_PATH}"stimuli.c"

DOMAIN_LIB_PATH="src/domains_library/"
CUSTOM_DOMAIN_FILE=${DOMAIN_LIB_PATH}"${CUSTOM_FILE_NAME}"
DEFAULT_DOMAIN_FILE=${DOMAIN_LIB_PATH}"domain.c"

EXTRA_DATA_LIB_PATH="src/extra_data_library/"
CUSTOM_EXTRA_DATA_FILE=${EXTRA_DATA_LIB_PATH}"${CUSTOM_FILE_NAME}"
DEFAULT_EXTRA_DATA_FILE=${EXTRA_DATA_LIB_PATH}"extra_data.c"

ECHOERR() { printf "%s\n" "$*" >&2; }

ADD_HEADER() {

	model_full_path=$1
	model_name=$2		
	include_guard="MONOALG3D_MODEL_${model_name^^}_H"

cat << EOF > "${model_full_path}/${model_name}.h"
#ifndef ${include_guard}
#define ${include_guard}

#include "../model_common.h"

#define NEQ COMPLETE_ME
#define INITIAL_V (COMPLETE_ME)

#ifdef __CUDACC__

#include "../../gpu_utils/gpu_utils.h"

__global__ void kernel_set_model_initial_conditions(real *sv, int num_volumes);

__global__ void solve_gpu(real cur_time, real dt, real *sv, real* stim_currents,
                          uint32_t *cells_to_solve, uint32_t num_cells_to_solve,
                          int num_steps);

inline __device__ void RHS_gpu(real *sv, real *rDY, real stim_current, int thread_id, real dt);
inline __device__ void solve_forward_euler_gpu_adpt(real *sv, real stim_curr, real final_time, int thread_id);

#endif

void RHS_cpu(const real *sv, real *rDY, real stim_current, real dt);
inline void solve_forward_euler_cpu_adpt(real *sv, real stim_curr, real final_time, int thread_id);

void solve_model_ode_cpu(real dt, real *sv, real stim_current);

#endif //${include_guard}
EOF
}

ADD_C_FILE() {

	model_full_path=$1
	model_name=$2		

cat << EOF > "${model_full_path}/${model_name}.c"
#include "${model_name}.h"
#include <stdlib.h>
real max_step;
real min_step;
real abstol;
real reltol;
bool adpt;
real *ode_dt, *ode_previous_dt, *ode_time_new;

GET_CELL_MODEL_DATA(init_cell_model_data) {

    if(get_initial_v)
        cell_model->initial_v = INITIAL_V;
    if(get_neq)
        cell_model->number_of_ode_equations = NEQ;
}

SET_ODE_INITIAL_CONDITIONS_CPU(set_model_initial_conditions_cpu) {

    log_to_stdout_and_file("Using ${model_name} CPU model\n");

    uint32_t num_cells = solver->original_num_cells;
    solver->sv = (real*)malloc(NEQ*num_cells*sizeof(real));

    max_step = solver->max_dt;
    min_step = solver->min_dt;
    abstol   = solver->abs_tol;
    reltol   = solver->rel_tol;
    adpt     = solver->adaptive;

    if(adpt) {
        ode_dt = (real*)malloc(num_cells*sizeof(real));

        OMP(parallel for)
        for(int i = 0; i < num_cells; i++) {
            ode_dt[i] = solver->min_dt;
        }

        ode_previous_dt = (real*)calloc(num_cells, sizeof(real));
        ode_time_new    = (real*)calloc(num_cells, sizeof(real));
        log_to_stdout_and_file("Using Adaptive Euler model to solve the ODEs\n");
    } else {
        log_to_stdout_and_file("Using Euler model to solve the ODEs\n");
    }
    OMP(parallel for)
    for(uint32_t i = 0; i < num_cells; i++) {

        real *sv = &solver->sv[i * NEQ];
		sv[0] = INITIAL_V;

		//TODO: implement the rest of the initial conditions

    }
}

SOLVE_MODEL_ODES(solve_model_odes_cpu) {

    uint32_t sv_id;

    size_t num_cells_to_solve = ode_solver->num_cells_to_solve;
    uint32_t * cells_to_solve = ode_solver->cells_to_solve;
    real *sv = ode_solver->sv;
    real dt = ode_solver->min_dt;
    uint32_t num_steps = ode_solver->num_steps;

    #pragma omp parallel for private(sv_id)
    for (uint32_t i = 0; i < num_cells_to_solve; i++) {

        if(cells_to_solve)
            sv_id = cells_to_solve[i];
        else
            sv_id = i;

        if(adpt) {

            solve_forward_euler_cpu_adpt(sv + (sv_id * NEQ), stim_currents[i], current_t + dt, sv_id);
        }
        else {
            for (int j = 0; j < num_steps; ++j) {
                solve_model_ode_cpu(dt, sv + (sv_id * NEQ), stim_currents[i]);
            }

        }

    }
}

void solve_model_ode_cpu(real dt, real *sv, real stim_current)  {

    real rY[NEQ], rDY[NEQ];

    for(int i = 0; i < NEQ; i++)
        rY[i] = sv[i];

    RHS_cpu(rY, rDY, stim_current, dt);

    for(int i = 0; i < NEQ; i++)
        sv[i] = dt*rDY[i] + rY[i];
}

void solve_forward_euler_cpu_adpt(real *sv, real stim_curr, real final_time, int sv_id) {

    real rDY[NEQ];

    real _tolerances_[NEQ];
    real _aux_tol = 0.0;
    //initializes the variables
    real dt = ode_dt[sv_id];
    real time_new = ode_time_new[sv_id];
    real previous_dt = ode_previous_dt[sv_id];

    real edos_old_aux_[NEQ];
    real edos_new_euler_[NEQ];
    real *_k1__ = (real*) malloc(sizeof(real)*NEQ);
    real *_k2__ = (real*) malloc(sizeof(real)*NEQ);
    real *_k_aux__;

    const real _beta_safety_ = 0.8;

    const real __tiny_ = pow(abstol, 2.0f);

    if(time_new + dt > final_time) {
       dt = final_time - time_new;
    }

    RHS_cpu(sv, rDY, stim_curr, dt);
    time_new += dt;

    for(int i = 0; i < NEQ; i++){
        _k1__[i] = rDY[i];
    }

    int count = 0;

    int count_limit = (final_time - time_new)/min_step;

    int aux_count_limit = count_limit+2000000;

    if(aux_count_limit > 0) {
        count_limit = aux_count_limit;
    }

    while(1) {

        for(int i = 0; i < NEQ; i++) {
            //stores the old variables in a vector
            edos_old_aux_[i] = sv[i];
            //computes euler method
            edos_new_euler_[i] = _k1__[i] * dt + edos_old_aux_[i];
            //steps ahead to compute the rk2 method
            sv[i] = edos_new_euler_[i];
        }

        time_new += dt;
        RHS_cpu(sv, rDY, stim_curr, dt);
        time_new -= dt;//step back

        double greatestError = 0.0, auxError = 0.0;
        for(int i = 0; i < NEQ; i++) {
            // stores the new evaluation
            _k2__[i] = rDY[i];
            _aux_tol = fabs(edos_new_euler_[i]) * reltol;
            _tolerances_[i] = (abstol > _aux_tol) ? abstol : _aux_tol;

            // finds the greatest error between  the steps
            auxError = fabs(((dt / 2.0) * (_k1__[i] - _k2__[i])) / _tolerances_[i]);

            greatestError = (auxError > greatestError) ? auxError : greatestError;
        }
        ///adapt the time step
        greatestError += __tiny_;
        previous_dt = dt;
        ///adapt the time step
        dt = _beta_safety_ * dt * sqrt(1.0f/greatestError);

        if (time_new + dt > final_time) {
            dt = final_time - time_new;
        }

        //it doesn't accept the solution
        if ( count < count_limit  && (greatestError >= 1.0f)) {
            //restore the old values to do it again
            for(int i = 0;  i < NEQ; i++) {
                sv[i] = edos_old_aux_[i];
            }
            count++;
            //throw the results away and compute again
        } else{//it accepts the solutions
            count = 0;

            if (dt < min_step) {
                dt = min_step;
            }

            else if (dt > max_step && max_step != 0) {
                dt = max_step;
            }

            if (time_new + dt > final_time) {
                dt = final_time - time_new;
            }

            _k_aux__ = _k2__;
            _k2__	= _k1__;
            _k1__	= _k_aux__;

            //it steps the method ahead, with euler solution
            for(int i = 0; i < NEQ; i++){
                sv[i] = edos_new_euler_[i];
            }

            if(time_new + previous_dt >= final_time) {
                if((fabs(final_time - time_new) < 1.0e-5)) {
                    break;
                } else if(time_new < final_time) {
                    dt = previous_dt = final_time - time_new;
                    time_new += previous_dt;
                    break;
                } else {
                    dt = previous_dt = min_step;
                    time_new += (final_time - time_new);
                    printf("Error: %lf\n", final_time - time_new);
                    break;
                }
            } else {
                time_new += previous_dt;
            }

        }
    }

	ode_dt[sv_id] = dt;
	ode_time_new[sv_id] = time_new;
	ode_previous_dt[sv_id] = previous_dt;
	
    free(_k1__);
    free(_k2__);
}

void RHS_cpu(const real *sv, real *rDY, real stim_current, real dt) {
	
	//TODO: implement

    #include "${model_name}_common.inc.c"

}
EOF
}

ADD_CU_FILE() {

	model_full_path=$1
	model_name=$2		

cat << EOF > "${model_full_path}/${model_name}.cu"
#include "${model_name}.h"
#include <stddef.h>
#include <stdint.h>

__constant__  size_t pitch;
__constant__  real abstol;
__constant__  real reltol;
__constant__  real max_dt;
__constant__  real min_dt;
__constant__  uint8_t use_adpt;
size_t pitch_h;

#define sv(i) *((real *)((char *)sv + pitch * (i)) + thread_id)

extern "C" SET_ODE_INITIAL_CONDITIONS_GPU(set_model_initial_conditions_gpu) {

    uint8_t use_adpt_h = (uint8_t)solver->adaptive;

    check_cuda_error(cudaMemcpyToSymbol(use_adpt, &use_adpt_h, sizeof(uint8_t)));
    log_to_stdout_and_file("Using ${model_name} GPU model\n");

    uint32_t num_volumes = solver->original_num_cells;

    if(use_adpt_h) {
        real reltol_h = solver->rel_tol;
        real abstol_h = solver->abs_tol;
        real max_dt_h = solver->max_dt;
        real min_dt_h = solver->min_dt;

        check_cuda_error(cudaMemcpyToSymbol(reltol, &reltol_h, sizeof(real)));
        check_cuda_error(cudaMemcpyToSymbol(abstol, &abstol_h, sizeof(real)));
        check_cuda_error(cudaMemcpyToSymbol(max_dt, &max_dt_h, sizeof(real)));
        check_cuda_error(cudaMemcpyToSymbol(min_dt, &min_dt_h, sizeof(real)));
        log_to_stdout_and_file("Using Adaptive Euler model to solve the ODEs\n");
    } else {
        log_to_stdout_and_file("Using Euler model to solve the ODEs\n");
    }

    // execution configuration
    const int GRID = (num_volumes + BLOCK_SIZE - 1) / BLOCK_SIZE;

    size_t size = num_volumes * sizeof(real);

    if(use_adpt_h)
        check_cuda_error(cudaMallocPitch((void **)&(solver->sv), &pitch_h, size, (size_t)NEQ + 3));
    else
        check_cuda_error(cudaMallocPitch((void **)&(solver->sv), &pitch_h, size, (size_t)NEQ));

    check_cuda_error(cudaMemcpyToSymbol(pitch, &pitch_h, sizeof(size_t)));

    kernel_set_model_initial_conditions<<<GRID, BLOCK_SIZE>>>(solver->sv, num_volumes);

    check_cuda_error(cudaPeekAtLastError());
    cudaDeviceSynchronize();
    return pitch_h;
}

extern "C" SOLVE_MODEL_ODES(solve_model_odes_gpu) {

    size_t num_cells_to_solve = ode_solver->num_cells_to_solve;
    uint32_t * cells_to_solve = ode_solver->cells_to_solve;
    real *sv = ode_solver->sv;
    real dt = ode_solver->min_dt;
    uint32_t num_steps = ode_solver->num_steps;

    // execution configuration
    const int GRID = ((int)num_cells_to_solve + BLOCK_SIZE - 1) / BLOCK_SIZE;

    size_t stim_currents_size = sizeof(real) * num_cells_to_solve;
    size_t cells_to_solve_size = sizeof(uint32_t) * num_cells_to_solve;

    real *stims_currents_device;
    check_cuda_error(cudaMalloc((void **)&stims_currents_device, stim_currents_size));
    check_cuda_error(cudaMemcpy(stims_currents_device, stim_currents, stim_currents_size, cudaMemcpyHostToDevice));

    // the array cells to solve is passed when we are using and adapative mesh
    uint32_t *cells_to_solve_device = NULL;
    if(cells_to_solve != NULL) {
        check_cuda_error(cudaMalloc((void **)&cells_to_solve_device, cells_to_solve_size));
        check_cuda_error(
            cudaMemcpy(cells_to_solve_device, cells_to_solve, cells_to_solve_size, cudaMemcpyHostToDevice));
    }

    solve_gpu<<<GRID, BLOCK_SIZE>>>(current_t, dt, sv, stims_currents_device, cells_to_solve_device, num_cells_to_solve,
                                    num_steps);

    check_cuda_error(cudaPeekAtLastError());

    check_cuda_error(cudaFree(stims_currents_device));
    if(cells_to_solve_device)
        check_cuda_error(cudaFree(cells_to_solve_device));
}

__global__ void kernel_set_model_initial_conditions(real *sv, int num_volumes) {
    int thread_id = blockDim.x * blockIdx.x + threadIdx.x;

    if (thread_id < num_volumes) {

		sv(0) = INITIAL_V;
		//TODO: implement the rest of the initial conditions

        if(use_adpt) {
			sv(NEQ) = min_dt; // dt
			sv(NEQ+1) = 0.0;    // time_new
			sv(NEQ+2) = 0.0;    // previous dt
        }
    }
}

// Solving the model for each cell in the tissue matrix ni x nj
__global__ void solve_gpu(real cur_time, real dt, real *sv, real *stim_currents, uint32_t *cells_to_solve,
                          uint32_t num_cells_to_solve, int num_steps) {
    int threadID = blockDim.x * blockIdx.x + threadIdx.x;
    int sv_id;

    // Each thread solves one cell model
    if(threadID < num_cells_to_solve) {
        if(cells_to_solve)
            sv_id = cells_to_solve[threadID];
        else
            sv_id = threadID;

        if(!use_adpt) {
            real rDY[NEQ];

            for(int n = 0; n < num_steps; ++n) {

                RHS_gpu(sv, rDY, stim_currents[threadID], sv_id, dt);

                for(int i = 0; i < NEQ; i++) {
                    *((real *)((char *)sv + pitch * i) + sv_id) =
                        dt * rDY[i] + *((real *)((char *)sv + pitch * i) + sv_id);
                }
            }
        } else {
            solve_forward_euler_gpu_adpt(sv, stim_currents[threadID], cur_time + max_dt, sv_id);
        }
    }
}

inline __device__ void solve_forward_euler_gpu_adpt(real *sv, real stim_curr, real final_time, int thread_id) {

    #define DT *((real *)((char *)sv + pitch * 30) + thread_id)
    #define TIME_NEW *((real *)((char *)sv + pitch * 31) + thread_id)
    #define PREVIOUS_DT *((real *)((char *)sv + pitch * 32) + thread_id)

    real rDY[NEQ];

    real _tolerances_[NEQ];
    real _aux_tol = 0.0;
    real dt = DT;
    real time_new = TIME_NEW;
    real previous_dt = PREVIOUS_DT;

    real edos_old_aux_[NEQ];
    real edos_new_euler_[NEQ];
    real _k1__[NEQ];
    real _k2__[NEQ];
    real _k_aux__[NEQ];
    real sv_local[NEQ];

    const real _beta_safety_ = 0.8;

    const real __tiny_ = pow(abstol, 2.0f);

    // dt = ((time_new + dt) > final_time) ? (final_time - time_new) : dt;
    if(time_new + dt > final_time) {
        dt = final_time - time_new;
    }

    //#pragma unroll
    for(int i = 0; i < NEQ; i++) {
        sv_local[i] = *((real *)((char *)sv + pitch * i) + thread_id);
    }

    RHS_gpu(sv_local, rDY, stim_curr, thread_id, dt);
    time_new += dt;

    //#pragma unroll
    for(int i = 0; i < NEQ; i++) {
        _k1__[i] = rDY[i];
    }

    int count = 0;

    int count_limit = (final_time - time_new) / min_dt;

    int aux_count_limit = count_limit + 2000000;

    if(aux_count_limit > 0) {
        count_limit = aux_count_limit;
    }

    while(1) {

        for(int i = 0; i < NEQ; i++) {
            // stores the old variables in a vector
            edos_old_aux_[i] = sv_local[i];
            // //computes euler method
            edos_new_euler_[i] = _k1__[i] * dt + edos_old_aux_[i];
            // steps ahead to compute the rk2 method
            sv_local[i] = edos_new_euler_[i];
        }

        time_new += dt;

        RHS_gpu(sv_local, rDY, stim_curr, thread_id, dt);
        time_new -= dt; // step back

        real greatestError = 0.0, auxError = 0.0;
        for(int i = 0; i < NEQ; i++) {

            // stores the new evaluation
            _k2__[i] = rDY[i];
            _aux_tol = fabs(edos_new_euler_[i]) * reltol;
            _tolerances_[i] = (abstol > _aux_tol) ? abstol : _aux_tol;

            // finds the greatest error between  the steps
            auxError = fabs(((dt / 2.0) * (_k1__[i] - _k2__[i])) / _tolerances_[i]);

            greatestError = (auxError > greatestError) ? auxError : greatestError;
        }

        /// adapt the time step
        greatestError += __tiny_;
        previous_dt = dt;
        /// adapt the time step
        dt = _beta_safety_ * dt * sqrt(1.0f / greatestError);

        if(time_new + dt > final_time) {
            dt = final_time - time_new;
        }

        // it doesn't accept the solution
        if(count < count_limit && (greatestError >= 1.0f)) {
            // restore the old values to do it again
            for(int i = 0; i < NEQ; i++) {
                sv_local[i] = edos_old_aux_[i];
            }
            count++;
            // throw the results away and compute again
        } else {
            count = 0;

            if(dt < min_dt) {
                dt = min_dt;
            }

            else if(dt > max_dt && max_dt != 0) {
                dt = max_dt;
            }

            if(time_new + dt > final_time) {
                dt = final_time - time_new;
            }

            // change vectors k1 e k2 , para que k2 seja aproveitado como k1 na proxima iteração
            for(int i = 0; i < NEQ; i++) {
                _k_aux__[i] = _k2__[i];
                _k2__[i] = _k1__[i];
                _k1__[i] = _k_aux__[i];
            }

            // it steps the method ahead, with euler solution
            for(int i = 0; i < NEQ; i++) {
                sv_local[i] = edos_new_euler_[i];
            }

            if(time_new + previous_dt >= final_time) {
                if((fabs(final_time - time_new) < 1.0e-5)) {
                    break;
                } else if(time_new < final_time) {
                    dt = previous_dt = final_time - time_new;
                    time_new += previous_dt;
                    break;
                } else {
                    dt = previous_dt = min_dt;
                    time_new += (final_time - time_new);
                    printf("Error: %d: %lf\n", thread_id, final_time - time_new);
                    break;
                }
            } else {
                time_new += previous_dt;
            }
        }
    }

    //#pragma unroll
    for(int i = 0; i < NEQ; i++) {
        *((real *)((char *)sv + pitch * i) + thread_id) = sv_local[i];
    }

    DT = dt;
    TIME_NEW = time_new;
    PREVIOUS_DT = previous_dt;
}

inline __device__ void RHS_gpu(real *sv, real *rDY, real stim_current, int thread_id, real dt) {
    //State variables
    
    if(use_adpt) {
		//TODO: implement
    } else {
		//TODO: implement
    }

    #include "${model_name}_common.inc.c"

}
EOF
}

ADD_INC_FILE() {

	model_full_path=$1
	model_name=$2		

cat << EOF > "${model_full_path}/${model_name}_common.inc.c"
//TODO: implement. This is where the math of the model needs to be written.
EOF
}

ADD_BUILD_FILE() {

	model_full_path=$1
	model_name=$2		
	model_folder=$3		

cat << EOF > "${model_full_path}/build.sh"
############## ${model_name} ##############################
MODEL_FILE_CPU="${model_name}.c"
MODEL_FILE_GPU="${model_name}.cu"
COMMON_HEADERS="${model_name}.h"

COMPILE_MODEL_LIB "${model_name}" "\$MODEL_FILE_CPU" "\$MODEL_FILE_GPU" "\$COMMON_HEADERS"
EOF

}


ADD_TEMPLATE_FILES() {

	ADD_HEADER     "$1" "$2"
	ADD_C_FILE     "$1" "$2"
	ADD_CU_FILE    "$1" "$2"
	ADD_INC_FILE   "$1" "$2"
	ADD_BUILD_FILE "$1" "$2" "$3"
}

CREATE_NEW_MODEL() {

	model_folder=$1

	model_name=$2

	model_full_path=src/models_library/${model_folder}/

	mkdir -p "$model_full_path"

	ADD_TEMPLATE_FILES "$model_full_path" "$model_name" "$model_folder"
}

FUNCTION_EXISTS() {
	local custom_file=$1	
	local default_file=$2
	local search_pattern=$3
	local function_name=$4

	result=$(grep [[:blank:]]*"${search_pattern}"[[:blank:]]*\([[:blank:]]*${function_name}[[:blank:]]*\)[[:blank:]]* "${custom_file}")
	result2=$(grep [[:blank:]]*"${search_pattern}"[[:blank:]]*\([[:blank:]]*${function_name}[[:blank:]]*\)[[:blank:]]* "${default_file}")

	if [ -n "${result}" ] || [ -n "${result2}" ]; then
		if [[ -z "${result}" ]]; then
			ECHOERR "[WARN] Function ${function_name} already exists in ${default_file} skipping!"
		else
			ECHOERR "[WARN] Function ${function_name} already exists in ${custom_file} skipping!"
		fi
		echo "1"
	fi

	echo "0"
}

WRITE_DOMAIN_FILE_HEADER() {
cat << EOF > "${CUSTOM_DOMAIN_FILE}"
#include "domain_helpers.h"

#include "../3dparty/sds/sds.h"
#include "../3dparty/stb_ds.h"
#include "../config/domain_config.h"
#include "../config_helpers/config_helpers.h"
#include "../libraries_common/common_data_structures.h"
#include "../logger/logger.h"
#include "../utils/utils.h"
#include <assert.h>
#include <time.h>

#include <float.h>
#include <unistd.h>
EOF
}

WRITE_DOMAIN_FUNCTION() {
cat << EOF >> "${CUSTOM_DOMAIN_FILE}"

SET_SPATIAL_DOMAIN(${function_name}) {
	return 1; //TODO: create a better example
}
EOF
}

CREATE_NEW_DOMAIN() {
	function_name=$1
	
	if [ ! -f "${CUSTOM_DOMAIN_FILE}" ]; then
		WRITE_DOMAIN_FILE_HEADER
	fi
	
	res=$(FUNCTION_EXISTS "${CUSTOM_DOMAIN_FILE}" "${DEFAULT_DOMAIN_FILE}" "SET_SPATIAL_DOMAIN" "$function_name")

	if [ "$res" == "0" ]; then
		WRITE_DOMAIN_FUNCTION
	fi
}

WRITE_STIM_FILE_HEADER() {
cat << EOF > "${CUSTOM_STIM_FILE}"
#include <stdbool.h>
#include <stdint.h> 
#include <stdlib.h> 

#include "../alg/grid/grid.h" 
#include "../config/stim_config.h"
#include "../config_helpers/config_helpers.h"
#include "../utils/utils.h"
EOF
}

WRITE_STIM_FUNCTION() {
cat << EOF >> "${CUSTOM_STIM_FILE}"

SET_SPATIAL_STIM(${function_name}) {

	uint32_t n_active = the_grid->num_active_cells;
	struct cell_node **ac = the_grid->active_cells;
	
	ALLOCATE_STIMS();

	real stim_current = 0.0;
	GET_PARAMETER_NUMERIC_VALUE_OR_REPORT_ERROR(real, stim_current, config, "current");

	bool stim;
	real stim_value;
	
	uint32_t i;

	OMP(parallel for private(stim, stim_value))
	for(i = 0; i < n_active; i++) {

		//TODO: define if a stimulus will be applied according to condition
		//Ex:
		// stim = ac[i]->center.x < 100;
		// will apply a stimulus in each cell that has the coordinate x
		// of its center < 100

		if(stim) {
			stim_value = stim_current;
		} else {
			stim_value = 0.0;
		}

		SET_STIM_VALUE(i, stim_value);
	}
}
EOF
}

CREATE_NEW_STIM() {
	function_name=$1

	if [ ! -f "${CUSTOM_STIM_FILE}" ]; then
		WRITE_STIM_FILE_HEADER
	fi
	
	res=$(FUNCTION_EXISTS "${CUSTOM_STIM_FILE}" "${DEFAULT_STIM_FILE}" "SET_SPATIAL_STIM" "$function_name")

	if [ "$res" == "0" ]; then
		WRITE_STIM_FUNCTION
	fi

}

WRITE_EXTRA_DATA_FILE_HEADER() {
cat << EOF >> "${CUSTOM_EXTRA_DATA_FILE}"
#include <unistd.h>

#include "../config/extra_data_config.h"
#include "../config_helpers/config_helpers.h"
#include "../libraries_common/common_data_structures.h"
#include "../utils/file_utils.h"
EOF
}

WRITE_EXTRA_DATA_FUNCTION() {
cat << EOF >> "${CUSTOM_EXTRA_DATA_FILE}"

SET_EXTRA_DATA(${function_name}) {
	
	//TODO: set the extra data size in bytes
	*extra_data_size = 0; 
	
	//TODO: extra data can be a pointer of any type (you have to  cast to void* before returning
    void *extra_data = malloc(*extra_data_size);

	return extra_data;
}
EOF
}

CREATE_NEW_EXTRA_DATA() {
	function_name=$1

	if [ ! -f "${CUSTOM_EXTRA_DATA_FILE}" ]; then
		WRITE_EXTRA_DATA_FILE_HEADER
	fi
	
	res=$(FUNCTION_EXISTS "${CUSTOM_EXTRA_DATA_FILE}" "${DEFAULT_EXTRA_DATA_FILE}" "SET_EXTRA_DATA" "$function_name")

	if [ "$res" == "0" ]; then
		WRITE_EXTRA_DATA_FUNCTION
	fi

}

CREATE_NEW_CONFIG() {

	local SIM_DIR=$1
	local SIM_CONFIG_FILE="$SIM_DIR/$1_config.ini"
	local SIM_OUTPUT_DIR="$SIM_DIR/output"

	local STIM_F_NAME="$2"
	local DOMAIN_F_NAME="$3"
    local EXTRA_DATA_F_NAME="$4"

	if [ ! -d "$SIM_DIR" ]; then
		mkdir "$SIM_DIR"
	else
		ECHOERR "Simulation directory $SIM_DIR alread exists. Delete it or choose a new simulation name!"
		exit 1
	fi


cat << EOF >> "${SIM_CONFIG_FILE}"
[main]
num_threads=2
dt_pde=0.02
simulation_time=400.0
abort_on_no_activity=false
use_adaptivity=false

[update_monodomain]
main_function=update_monodomain_default

[save_result]
print_rate=1
output_dir=${SIM_OUTPUT_DIR}
main_function=save_as_vtu
init_function=init_save_as_vtk_or_vtu
end_function=end_save_as_vtk_or_vtu
file_prefix=V

[assembly_matrix]
init_function=set_initial_conditions_fvm
sigma_x=0.0000176
sigma_y=0.0001334
sigma_z=0.0000176
main_function=homogeneous_sigma_assembly_matrix

[linear_system_solver]
tolerance=1e-16
use_gpu=yes
max_iterations=200
main_function=conjugate_gradient
init_function=init_conjugate_gradient
end_function=end_conjugate_gradient

[domain]
name=$1 Mesh
main_function=$DOMAIN_F_NAME

[ode_solver]
dt=0.02
use_gpu=yes
gpu_id=0
library_file=shared_libs/libten_tusscher_2006.so

[stim_1]
start = 0.0
duration = 2.0
current = -50.0
main_function=$STIM_F_NAME

[extra_data]
main_function=$EXTRA_DATA_F_NAME

EOF

echo "The new configuration file was successfuly generated in $SIM_CONFIG_FILE."

}

COMMON_COMMAND_ERROR() {

	ECHOERR "$1 command need 1 parameter (new $1 function name)"
	ECHOERR "Example usage:" 
	ECHOERR "$0 my_custom_$1"
	ECHOERR "This command will create or add a new $1 function in ${2}"
	exit
}

MAIN() {

	case $1 in
		simulation)
			if [ $# -ne 2 ]
			then
				ECHOERR "$1 command need 1 parameter (simulation name)"
				exit
			fi

			local STIM_F_NAME="$2_stim_function"
			local DOMAIN_F_NAME="$2_domain_function"
			local EXTRA_DATA_F_NAME="$2_extra_data_function"


			CREATE_NEW_CONFIG "$2" "$STIM_F_NAME" "$DOMAIN_F_NAME" "$EXTRA_DATA_F_NAME"
			CREATE_NEW_STIM "$STIM_F_NAME"
			CREATE_NEW_DOMAIN "$DOMAIN_F_NAME"
			CREATE_NEW_EXTRA_DATA "$EXTRA_DATA_F_NAME"
			;;
		model) 
			if [ $# -ne 3 ]
			then
				ECHOERR "$1 command need 2 parameters (new model folder and new model name)"
				ECHOERR "Example usage:" 
				ECHOERR "$0 ten_tuscher ten_tuscher_2009" 
				ECHOERR "This command will create a template model file called ten_tuscher_2009 in the src/models_library/ten_tuscher folder."
				exit
			fi
			CREATE_NEW_MODEL "$2" "$3"
			;;

		stimulus) 
			if [ $# -ne 2 ]
			then
				COMMON_COMMAND_ERROR "$1" "$CUSTOM_STIM_FILE"
			fi
			CREATE_NEW_STIM "$2"
			;;
		domain) 
			if [ $# -ne 2 ]
			then
				COMMON_COMMAND_ERROR "$1" "$CUSTOM_DOMAIN_FILE"
			fi
			CREATE_NEW_DOMAIN "$2"
			;;
		extra_data) 
			if [ $# -ne 2 ]
			then
				COMMON_COMMAND_ERROR "$1" "$CUSTOM_EXTRA_DATA_FILE"

			fi
			CREATE_NEW_EXTRA_DATA "$2"
			;;
		*)
			ECHOERR 
			ECHOERR "Invalid command:" "$@"
			ECHOERR 
			ECHOERR "Available commands: "
			ECHOERR 
			ECHOERR "$0" "simulation simulation_name"
			ECHOERR "$0" "model model_folder model_name"
			ECHOERR "$0" "stimulus function_name"
			ECHOERR "$0" "domain function_name"
			ECHOERR "$0" "extra_data function_name"
			ECHOERR 
			;;

	esac
}

MAIN "$@"
