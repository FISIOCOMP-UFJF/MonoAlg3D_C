#!/bin/bash

CUSTOM_STIM_FILE="src/stimuli_library/custom_stimuli_functions.c"
CUSTOM_DOMAIN_FILE="src/domains_library/custom_domain_functions.c"
CUSTOM_FILE=""

ECHOERR() { printf "%s\n" "$*" >&2; }

ADD_HEADER() {

	model_full_path=$1
	model_name=$2		
	include_guard="MONOALG3D_MODEL_${model_name^^}_H"

cat << EOF > "${model_full_path}/${model_name}.h"
#ifndef ${include_guard}
#define ${include_guard}

#include "../model_common.h"

#define NEQ COMPLETE_ME
#define INITIAL_V (COMPLETE_ME)

#ifdef __CUDACC__

#include "../../gpu_utils/gpu_utils.h"

__global__ void kernel_set_model_initial_conditions(real *sv, int num_volumes);

__global__ void solve_gpu(real cur_time, real dt, real *sv, real* stim_currents,
                          uint32_t *cells_to_solve, uint32_t num_cells_to_solve,
                          int num_steps);

inline __device__ void RHS_gpu(real *sv, real *rDY, real stim_current, int thread_id, real dt);
inline __device__ void solve_forward_euler_gpu_adpt(real *sv, real stim_curr, real final_time, int thread_id);

#endif

void RHS_cpu(const real *sv, real *rDY, real stim_current, real dt);
inline void solve_forward_euler_cpu_adpt(real *sv, real stim_curr, real final_time, int thread_id);

void solve_model_ode_cpu(real dt, real *sv, real stim_current);

#endif //${include_guard}
EOF
}

ADD_C_FILE() {

	model_full_path=$1
	model_name=$2		

cat << EOF > "${model_full_path}/${model_name}.c"
#include "${model_name}.h"
#include <stdlib.h>
real max_step;
real min_step;
real abstol;
real reltol;
bool adpt;
real *ode_dt, *ode_previous_dt, *ode_time_new;

GET_CELL_MODEL_DATA(init_cell_model_data) {

    if(get_initial_v)
        cell_model->initial_v = INITIAL_V;
    if(get_neq)
        cell_model->number_of_ode_equations = NEQ;
}

SET_ODE_INITIAL_CONDITIONS_CPU(set_model_initial_conditions_cpu) {

    log_to_stdout_and_file("Using ${model_name} CPU model\n");

    uint32_t num_cells = solver->original_num_cells;
    solver->sv = (real*)malloc(NEQ*num_cells*sizeof(real));

    max_step = solver->max_dt;
    min_step = solver->min_dt;
    abstol   = solver->abs_tol;
    reltol   = solver->rel_tol;
    adpt     = solver->adaptive;

    if(adpt) {
        ode_dt = (real*)malloc(num_cells*sizeof(real));

        OMP(parallel for)
        for(int i = 0; i < num_cells; i++) {
            ode_dt[i] = solver->min_dt;
        }

        ode_previous_dt = (real*)calloc(num_cells, sizeof(real));
        ode_time_new    = (real*)calloc(num_cells, sizeof(real));
        log_to_stdout_and_file("Using Adaptive Euler model to solve the ODEs\n");
    } else {
        log_to_stdout_and_file("Using Euler model to solve the ODEs\n");
    }
    OMP(parallel for)
    for(uint32_t i = 0; i < num_cells; i++) {

        real *sv = &solver->sv[i * NEQ];
		sv[0] = INITIAL_V;

		//TODO: implement the rest of the initial conditions

    }
}

SOLVE_MODEL_ODES(solve_model_odes_cpu) {

    uint32_t sv_id;

    size_t num_cells_to_solve = ode_solver->num_cells_to_solve;
    uint32_t * cells_to_solve = ode_solver->cells_to_solve;
    real *sv = ode_solver->sv;
    real dt = ode_solver->min_dt;
    uint32_t num_steps = ode_solver->num_steps;

    #pragma omp parallel for private(sv_id)
    for (uint32_t i = 0; i < num_cells_to_solve; i++) {

        if(cells_to_solve)
            sv_id = cells_to_solve[i];
        else
            sv_id = i;

        if(adpt) {

            solve_forward_euler_cpu_adpt(sv + (sv_id * NEQ), stim_currents[i], current_t + dt, sv_id);
        }
        else {
            for (int j = 0; j < num_steps; ++j) {
                solve_model_ode_cpu(dt, sv + (sv_id * NEQ), stim_currents[i]);
            }

        }

    }
}

void solve_model_ode_cpu(real dt, real *sv, real stim_current)  {

    real rY[NEQ], rDY[NEQ];

    for(int i = 0; i < NEQ; i++)
        rY[i] = sv[i];

    RHS_cpu(rY, rDY, stim_current, dt);

    for(int i = 0; i < NEQ; i++)
        sv[i] = dt*rDY[i] + rY[i];
}

void solve_forward_euler_cpu_adpt(real *sv, real stim_curr, real final_time, int sv_id) {

    real rDY[NEQ];

    real _tolerances_[NEQ];
    real _aux_tol = 0.0;
    //initializes the variables
    real dt = ode_dt[sv_id];
    real time_new = ode_time_new[sv_id];
    real previous_dt = ode_previous_dt[sv_id];

    real edos_old_aux_[NEQ];
    real edos_new_euler_[NEQ];
    real *_k1__ = (real*) malloc(sizeof(real)*NEQ);
    real *_k2__ = (real*) malloc(sizeof(real)*NEQ);
    real *_k_aux__;

    const real _beta_safety_ = 0.8;

    const real __tiny_ = pow(abstol, 2.0f);

    if(time_new + dt > final_time) {
       dt = final_time - time_new;
    }

    RHS_cpu(sv, rDY, stim_curr, dt);
    time_new += dt;

    for(int i = 0; i < NEQ; i++){
        _k1__[i] = rDY[i];
    }

    int count = 0;

    int count_limit = (final_time - time_new)/min_step;

    int aux_count_limit = count_limit+2000000;

    if(aux_count_limit > 0) {
        count_limit = aux_count_limit;
    }

    while(1) {

        for(int i = 0; i < NEQ; i++) {
            //stores the old variables in a vector
            edos_old_aux_[i] = sv[i];
            //computes euler method
            edos_new_euler_[i] = _k1__[i] * dt + edos_old_aux_[i];
            //steps ahead to compute the rk2 method
            sv[i] = edos_new_euler_[i];
        }

        time_new += dt;
        RHS_cpu(sv, rDY, stim_curr, dt);
        time_new -= dt;//step back

        double greatestError = 0.0, auxError = 0.0;
        for(int i = 0; i < NEQ; i++) {
            // stores the new evaluation
            _k2__[i] = rDY[i];
            _aux_tol = fabs(edos_new_euler_[i]) * reltol;
            _tolerances_[i] = (abstol > _aux_tol) ? abstol : _aux_tol;

            // finds the greatest error between  the steps
            auxError = fabs(((dt / 2.0) * (_k1__[i] - _k2__[i])) / _tolerances_[i]);

            greatestError = (auxError > greatestError) ? auxError : greatestError;
        }
        ///adapt the time step
        greatestError += __tiny_;
        previous_dt = dt;
        ///adapt the time step
        dt = _beta_safety_ * dt * sqrt(1.0f/greatestError);

        if (time_new + dt > final_time) {
            dt = final_time - time_new;
        }

        //it doesn't accept the solution
        if ( count < count_limit  && (greatestError >= 1.0f)) {
            //restore the old values to do it again
            for(int i = 0;  i < NEQ; i++) {
                sv[i] = edos_old_aux_[i];
            }
            count++;
            //throw the results away and compute again
        } else{//it accepts the solutions
            count = 0;

            if (dt < min_step) {
                dt = min_step;
            }

            else if (dt > max_step && max_step != 0) {
                dt = max_step;
            }

            if (time_new + dt > final_time) {
                dt = final_time - time_new;
            }

            _k_aux__ = _k2__;
            _k2__	= _k1__;
            _k1__	= _k_aux__;

            //it steps the method ahead, with euler solution
            for(int i = 0; i < NEQ; i++){
                sv[i] = edos_new_euler_[i];
            }

            if(time_new + previous_dt >= final_time) {
                if((fabs(final_time - time_new) < 1.0e-5)) {
                    break;
                } else if(time_new < final_time) {
                    dt = previous_dt = final_time - time_new;
                    time_new += previous_dt;
                    break;
                } else {
                    dt = previous_dt = min_step;
                    time_new += (final_time - time_new);
                    printf("Error: %lf\n", final_time - time_new);
                    break;
                }
            } else {
                time_new += previous_dt;
            }

        }
    }

	ode_dt[sv_id] = dt;
	ode_time_new[sv_id] = time_new;
	ode_previous_dt[sv_id] = previous_dt;
	
    free(_k1__);
    free(_k2__);
}

void RHS_cpu(const real *sv, real *rDY, real stim_current, real dt) {
	
	//TODO: implement

    #include "${model_name}_common.inc.c"

}
EOF
}

ADD_CU_FILE() {

	model_full_path=$1
	model_name=$2		

cat << EOF > "${model_full_path}/${model_name}.cu"
#include "${model_name}.h"
#include <stddef.h>
#include <stdint.h>

__constant__  size_t pitch;
__constant__  real abstol;
__constant__  real reltol;
__constant__  real max_dt;
__constant__  real min_dt;
__constant__  uint8_t use_adpt;
size_t pitch_h;

#define sv(i) *((real *)((char *)sv + pitch * (i)) + thread_id)

extern "C" SET_ODE_INITIAL_CONDITIONS_GPU(set_model_initial_conditions_gpu) {

    uint8_t use_adpt_h = (uint8_t)solver->adaptive;

    check_cuda_error(cudaMemcpyToSymbol(use_adpt, &use_adpt_h, sizeof(uint8_t)));
    log_to_stdout_and_file("Using ${model_name} GPU model\n");

    uint32_t num_volumes = solver->original_num_cells;

    if(use_adpt_h) {
        real reltol_h = solver->rel_tol;
        real abstol_h = solver->abs_tol;
        real max_dt_h = solver->max_dt;
        real min_dt_h = solver->min_dt;

        check_cuda_error(cudaMemcpyToSymbol(reltol, &reltol_h, sizeof(real)));
        check_cuda_error(cudaMemcpyToSymbol(abstol, &abstol_h, sizeof(real)));
        check_cuda_error(cudaMemcpyToSymbol(max_dt, &max_dt_h, sizeof(real)));
        check_cuda_error(cudaMemcpyToSymbol(min_dt, &min_dt_h, sizeof(real)));
        log_to_stdout_and_file("Using Adaptive Euler model to solve the ODEs\n");
    } else {
        log_to_stdout_and_file("Using Euler model to solve the ODEs\n");
    }

    // execution configuration
    const int GRID = (num_volumes + BLOCK_SIZE - 1) / BLOCK_SIZE;

    size_t size = num_volumes * sizeof(real);

    if(use_adpt_h)
        check_cuda_error(cudaMallocPitch((void **)&(solver->sv), &pitch_h, size, (size_t)NEQ + 3));
    else
        check_cuda_error(cudaMallocPitch((void **)&(solver->sv), &pitch_h, size, (size_t)NEQ));

    check_cuda_error(cudaMemcpyToSymbol(pitch, &pitch_h, sizeof(size_t)));

    kernel_set_model_initial_conditions<<<GRID, BLOCK_SIZE>>>(solver->sv, num_volumes);

    check_cuda_error(cudaPeekAtLastError());
    cudaDeviceSynchronize();
    return pitch_h;
}

extern "C" SOLVE_MODEL_ODES(solve_model_odes_gpu) {

    size_t num_cells_to_solve = ode_solver->num_cells_to_solve;
    uint32_t * cells_to_solve = ode_solver->cells_to_solve;
    real *sv = ode_solver->sv;
    real dt = ode_solver->min_dt;
    uint32_t num_steps = ode_solver->num_steps;

    // execution configuration
    const int GRID = ((int)num_cells_to_solve + BLOCK_SIZE - 1) / BLOCK_SIZE;

    size_t stim_currents_size = sizeof(real) * num_cells_to_solve;
    size_t cells_to_solve_size = sizeof(uint32_t) * num_cells_to_solve;

    real *stims_currents_device;
    check_cuda_error(cudaMalloc((void **)&stims_currents_device, stim_currents_size));
    check_cuda_error(cudaMemcpy(stims_currents_device, stim_currents, stim_currents_size, cudaMemcpyHostToDevice));

    // the array cells to solve is passed when we are using and adapative mesh
    uint32_t *cells_to_solve_device = NULL;
    if(cells_to_solve != NULL) {
        check_cuda_error(cudaMalloc((void **)&cells_to_solve_device, cells_to_solve_size));
        check_cuda_error(
            cudaMemcpy(cells_to_solve_device, cells_to_solve, cells_to_solve_size, cudaMemcpyHostToDevice));
    }

    solve_gpu<<<GRID, BLOCK_SIZE>>>(current_t, dt, sv, stims_currents_device, cells_to_solve_device, num_cells_to_solve,
                                    num_steps);

    check_cuda_error(cudaPeekAtLastError());

    check_cuda_error(cudaFree(stims_currents_device));
    if(cells_to_solve_device)
        check_cuda_error(cudaFree(cells_to_solve_device));
}

__global__ void kernel_set_model_initial_conditions(real *sv, int num_volumes) {
    int thread_id = blockDim.x * blockIdx.x + threadIdx.x;

    if (thread_id < num_volumes) {

		sv(0) = INITIAL_V;
		//TODO: implement the rest of the initial conditions

        if(use_adpt) {
			sv(NEQ) = min_dt; // dt
			sv(NEQ+1) = 0.0;    // time_new
			sv(NEQ+2) = 0.0;    // previous dt
        }
    }
}

// Solving the model for each cell in the tissue matrix ni x nj
__global__ void solve_gpu(real cur_time, real dt, real *sv, real *stim_currents, uint32_t *cells_to_solve,
                          uint32_t num_cells_to_solve, int num_steps) {
    int threadID = blockDim.x * blockIdx.x + threadIdx.x;
    int sv_id;

    // Each thread solves one cell model
    if(threadID < num_cells_to_solve) {
        if(cells_to_solve)
            sv_id = cells_to_solve[threadID];
        else
            sv_id = threadID;

        if(!use_adpt) {
            real rDY[NEQ];

            for(int n = 0; n < num_steps; ++n) {

                RHS_gpu(sv, rDY, stim_currents[threadID], sv_id, dt);

                for(int i = 0; i < NEQ; i++) {
                    *((real *)((char *)sv + pitch * i) + sv_id) =
                        dt * rDY[i] + *((real *)((char *)sv + pitch * i) + sv_id);
                }
            }
        } else {
            solve_forward_euler_gpu_adpt(sv, stim_currents[threadID], cur_time + max_dt, sv_id);
        }
    }
}

inline __device__ void solve_forward_euler_gpu_adpt(real *sv, real stim_curr, real final_time, int thread_id) {

    #define DT *((real *)((char *)sv + pitch * 30) + thread_id)
    #define TIME_NEW *((real *)((char *)sv + pitch * 31) + thread_id)
    #define PREVIOUS_DT *((real *)((char *)sv + pitch * 32) + thread_id)

    real rDY[NEQ];

    real _tolerances_[NEQ];
    real _aux_tol = 0.0;
    real dt = DT;
    real time_new = TIME_NEW;
    real previous_dt = PREVIOUS_DT;

    real edos_old_aux_[NEQ];
    real edos_new_euler_[NEQ];
    real _k1__[NEQ];
    real _k2__[NEQ];
    real _k_aux__[NEQ];
    real sv_local[NEQ];

    const real _beta_safety_ = 0.8;

    const real __tiny_ = pow(abstol, 2.0f);

    // dt = ((time_new + dt) > final_time) ? (final_time - time_new) : dt;
    if(time_new + dt > final_time) {
        dt = final_time - time_new;
    }

    //#pragma unroll
    for(int i = 0; i < NEQ; i++) {
        sv_local[i] = *((real *)((char *)sv + pitch * i) + thread_id);
    }

    RHS_gpu(sv_local, rDY, stim_curr, thread_id, dt);
    time_new += dt;

    //#pragma unroll
    for(int i = 0; i < NEQ; i++) {
        _k1__[i] = rDY[i];
    }

    int count = 0;

    int count_limit = (final_time - time_new) / min_dt;

    int aux_count_limit = count_limit + 2000000;

    if(aux_count_limit > 0) {
        count_limit = aux_count_limit;
    }

    while(1) {

        for(int i = 0; i < NEQ; i++) {
            // stores the old variables in a vector
            edos_old_aux_[i] = sv_local[i];
            // //computes euler method
            edos_new_euler_[i] = _k1__[i] * dt + edos_old_aux_[i];
            // steps ahead to compute the rk2 method
            sv_local[i] = edos_new_euler_[i];
        }

        time_new += dt;

        RHS_gpu(sv_local, rDY, stim_curr, thread_id, dt);
        time_new -= dt; // step back

        real greatestError = 0.0, auxError = 0.0;
        for(int i = 0; i < NEQ; i++) {

            // stores the new evaluation
            _k2__[i] = rDY[i];
            _aux_tol = fabs(edos_new_euler_[i]) * reltol;
            _tolerances_[i] = (abstol > _aux_tol) ? abstol : _aux_tol;

            // finds the greatest error between  the steps
            auxError = fabs(((dt / 2.0) * (_k1__[i] - _k2__[i])) / _tolerances_[i]);

            greatestError = (auxError > greatestError) ? auxError : greatestError;
        }

        /// adapt the time step
        greatestError += __tiny_;
        previous_dt = dt;
        /// adapt the time step
        dt = _beta_safety_ * dt * sqrt(1.0f / greatestError);

        if(time_new + dt > final_time) {
            dt = final_time - time_new;
        }

        // it doesn't accept the solution
        if(count < count_limit && (greatestError >= 1.0f)) {
            // restore the old values to do it again
            for(int i = 0; i < NEQ; i++) {
                sv_local[i] = edos_old_aux_[i];
            }
            count++;
            // throw the results away and compute again
        } else {
            count = 0;

            if(dt < min_dt) {
                dt = min_dt;
            }

            else if(dt > max_dt && max_dt != 0) {
                dt = max_dt;
            }

            if(time_new + dt > final_time) {
                dt = final_time - time_new;
            }

            // change vectors k1 e k2 , para que k2 seja aproveitado como k1 na proxima iteração
            for(int i = 0; i < NEQ; i++) {
                _k_aux__[i] = _k2__[i];
                _k2__[i] = _k1__[i];
                _k1__[i] = _k_aux__[i];
            }

            // it steps the method ahead, with euler solution
            for(int i = 0; i < NEQ; i++) {
                sv_local[i] = edos_new_euler_[i];
            }

            if(time_new + previous_dt >= final_time) {
                if((fabs(final_time - time_new) < 1.0e-5)) {
                    break;
                } else if(time_new < final_time) {
                    dt = previous_dt = final_time - time_new;
                    time_new += previous_dt;
                    break;
                } else {
                    dt = previous_dt = min_dt;
                    time_new += (final_time - time_new);
                    printf("Error: %d: %lf\n", thread_id, final_time - time_new);
                    break;
                }
            } else {
                time_new += previous_dt;
            }
        }
    }

    //#pragma unroll
    for(int i = 0; i < NEQ; i++) {
        *((real *)((char *)sv + pitch * i) + thread_id) = sv_local[i];
    }

    DT = dt;
    TIME_NEW = time_new;
    PREVIOUS_DT = previous_dt;
}



inline __device__ void RHS_gpu(real *sv, real *rDY, real stim_current, int thread_id, real dt) {
    //State variables
    
    if(use_adpt) {
		//TODO: implement
    } else {
		//TODO: implement
    }

    #include "${model_name}_common.inc.c"

}
EOF
}

ADD_INC_FILE() {

	model_full_path=$1
	model_name=$2		

cat << EOF > "${model_full_path}/${model_name}_common.inc.c"
//TODO: implement. This is where the math of the model needs to be written.
EOF
}

ADD_BUILD_FILE() {

	model_full_path=$1
	model_name=$2		
	model_folder=$3		

cat << EOF > "${model_full_path}/build.sh"
############## ${model_name} ##############################
MODEL_FILE_CPU="${model_name}.c"
MODEL_FILE_GPU="${model_name}.cu"
COMMON_HEADERS="${model_name}.h"

COMPILE_MODEL_LIB "${model_name}" "\$MODEL_FILE_CPU" "\$MODEL_FILE_GPU" "\$COMMON_HEADERS"
EOF

}


ADD_TEMPLATE_FILES() {

	ADD_HEADER $1 $2
	ADD_C_FILE $1 $2
	ADD_CU_FILE $1 $2
	ADD_INC_FILE $1 $2
	ADD_BUILD_FILE $1 $2 $3
}

CREATE_NEW_MODEL() {

	model_folder=$1

	model_name=$2

	model_full_path=src/models_library/${model_folder}/

	mkdir -p "$model_full_path"

	ADD_TEMPLATE_FILES "$model_full_path" "$model_name" "$model_folder"
}



CREATE_NEW_DOMAIN() {
	function_name=$1
	
	if [ ! -f "${CUSTOM_FILE}" ]; then

cat << EOF > "${CUSTOM_FILE}"
#include "domain_helpers.h"

#include "../3dparty/sds/sds.h"
#include "../3dparty/stb_ds.h"
#include "../config/domain_config.h"
#include "../config_helpers/config_helpers.h"
#include "../libraries_common/common_data_structures.h"
#include "../logger/logger.h"
#include "../utils/utils.h"
#include <assert.h>
#include <time.h>

#include <float.h>
#include <unistd.h>
EOF

	fi

		#TODO: check if this function alread exists in the main library file
		result=`grep [[:blank:]]*SET_SPATIAL_DOMAIN[[:blank:]]*\([[:blank:]]*${function_name}[[:blank:]]*\)[[:blank:]]* ${CUSTOM_FILE}`

	    if [[ -z "${result}" ]]; then

cat << EOF >> "${CUSTOM_FILE}"

SET_SPATIAL_DOMAIN(${function_name}) {
	return 1; //TODO: create a better example
}
EOF
	else
		ECHOERR "Function ${function_name} already exists in ${CUSTOM_FILE}"
	fi
}

CREATE_NEW_STIM() {
	function_name=$1

	if [ ! -f "${CUSTOM_FILE}" ]; then

cat << EOF > "${CUSTOM_FILE}"
#include <stdbool.h>
#include <stdint.h> 
#include <stdlib.h> 

#include "../alg/grid/grid.h" 
#include "../config/stim_config.h"
#include "../config_helpers/config_helpers.h"
#include "../utils/utils.h"
EOF

	fi

		result=`grep [[:blank:]]*SET_SPATIAL_STIM[[:blank:]]*\([[:blank:]]*${function_name}[[:blank:]]*\)[[:blank:]]* ${CUSTOM_FILE}`

	    if [[ -z "${result}" ]]; then

cat << EOF >> "${CUSTOM_FILE}"

SET_SPATIAL_STIM(${function_name}) {

	uint32_t n_active = the_grid->num_active_cells;
	struct cell_node **ac = the_grid->active_cells;
	
	ALLOCATE_STIMS();

	real stim_current = 0.0;
	GET_PARAMETER_NUMERIC_VALUE_OR_REPORT_ERROR(real, stim_current, config->config_data, "current");

	bool stim;
	real stim_value;
	
	uint32_t i;

	OMP(parallel for private(stim, stim_value))
	for(i = 0; i < n_active; i++) {

		//TODO: define if a stimulus will be applied according to condition
		//Ex:
		// stim = ac[i]->center.x < 100;
		// will apply a stimulus in each cell that has the coordinate x
		// of its center < 100

		if(stim) {
			stim_value = stim_current;
		} else {
			stim_value = 0.0;
		}

		SET_STIM_VALUE(i, stim_value);
	}
}
EOF
	else
		ECHOERR "Function ${function_name} already exists in ${CUSTOM_FILE}"
	fi
}

COMMON_COMMAND_ERROR() {

	ECHOERR "$1 command need 1 parameter (new $1 function name)"
	ECHOERR "Example usage:" 
	ECHOERR "$0 my_custom_$1"
	ECHOERR "This command will create or add a new $1 function in ${CUSTOM_FILE}"
	exit
}

MAIN() {

	case $1 in
		model) 
			if [ $# -ne 3 ]
			then
				ECHOERR "$1 command need 2 parameters (new model folder and new model name)"
				ECHOERR "Example usage:" 
				ECHOERR "$0 ten_tuscher ten_tuscher_2009" 
				ECHOERR "This command will create a template model file called ten_tuscher_2009 in the src/models_library/ten_tuscher folder."
				exit
			fi
			CREATE_NEW_MODEL "$2" "$3"
			;;

		stimulus) 
			CUSTOM_FILE=${CUSTOM_STIM_FILE}

			if [ $# -ne 2 ]
			then
				COMMON_COMMAND_ERROR $@
			fi
			CREATE_NEW_STIM "$2"
			;;
		domain) 
			CUSTOM_FILE=${CUSTOM_DOMAIN_FILE}
			if [ $# -ne 2 ]
			then
				COMMON_COMMAND_ERROR $@
			fi
			CREATE_NEW_DOMAIN "$2"
			;;

	esac
}

MAIN $@
